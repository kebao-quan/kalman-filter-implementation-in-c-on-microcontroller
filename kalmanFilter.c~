#include <stdio.h>
#include <stdint.h>


#define M(m, i, j)   *((m)->matrix + (i)*((m)->rows) + (j))

typedef struct {
	uint8_t rows;
	uint8_t cols;
	double* matrix;
} Matrix;

void createMatrix(Matrix* A, uint8_t rows, uint8_t cols, double* matrix) {
	A->rows = rows;
	A->cols = cols;
	A->matrix = matrix;
}

void multiply(Matrix *A, Matrix *B, Matrix *result) {
	if (A->cols != B->rows) return;
	if ((result->rows != A->rows) || (result->cols != B->cols)) return;

	uint8_t r = A->rows;
	uint8_t c = B->cols;
	uint8_t i, j;
	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++) {
			double sum = 0;
			uint8_t k;
			for (k = 0; k < A->cols; k++) {
				sum += M(A, i, k) * M(B, k, j); 
			}
			M(result, i, j) = sum;
		}
	}
	
}


void printMatrix(Matrix *m) {
	uint8_t i, j;
	for (i = 0; i < m->rows; i++) {
		for (j = 0; j < m->cols; j++) {
			printf("%03f ", M(m, i, j));
		}
		printf("\n");
	}
	
}

int main() {
	double F_[4] = {
		1, 0,
		0, 1
	};
	Matrix F;
	createMatrix(&F, 2, 2, F_);


	double A_[6] = {
		1, 2, 3,
		4, 5, 6
	};
	Matrix A;
	createMatrix(&A, 2, 3, A_);

	double B_[6] = {
		10, 11,
		20, 21,
		30, 31
	};
	Matrix B;
	createMatrix(&B, 3, 2, B_);

	double AB_[4] = {0};
	Matrix AB;
	createMatrix(&AB, 2, 2, AB_);
	//multiply(&A, &B, &AB);
	
	printMatrix(&AB);

	/* double H_[1][2] = { */
	/* 	{1, 0} */
	/* }; */
	/* Matrix H; */
	/* createMatrix(&H, 1, 2, H_); */

	/* const double HT[4][2] = { */
	/* 	{1, 0}, */
	/* 	{0, 1}, */
	/* 	{0, 0}, */
	/* 	{0, 0} */
	/* }; */

	/* const double R[2][2] = { */
	/* 	{10, 0}, */
	/* 	{0, 10} */
	/* }; */

	/* double P[4][4] = { */
	/* 	{1000, 0, 0, 0}, */
	/* 	{0, 1000, 0, 0}, */
	/* 	{0, 0, 1000, 0}, */
	/* 	{0, 0, 0, 1000} */
	/* }; */

}

/* double x_prev[4] = {0, 0, 0, 0}; */
/* double x_post[4] = {0, 0, 0, 0}; */

/* // Function to multiply two 4x4 matrices A and B, storing the result in C */
/* void multiply(int A[4][4], int B[4][4], int C[4][4]) { */
/*     for (int i = 0; i < 4; i++) { */
/*         for (int j = 0; j < 4; j++) { */
/*             C[i][j] = 0; */
/*             for (int k = 0; k < 4; k++) { */
/*                 C[i][j] += A[i][k] * B[k][j]; */
/*             } */
/*         } */
/*     } */
/* } */


/* void init(double x, double y) { */
/* 	x_prev[0] = x; */
/* 	x_prev[1] = y; */
/* } */


/* //Input: Previous State Vector. {x, y, x', y'} */
/* void predict() { */
/* 	x_post[0] = F[0][0] * x_prev[0] + F[0][2] * x_prev[2]; */
/* 	x_post[1] = F[1][1] * x_prev[1] + F[1][3] * x_prev[3]; */
/* 	x_post[2] = F[2][2] * x_prev[2]; */
/* 	x_post[3] = F[3][3] * x_prev[3]; */

/* 	double res[4][4]; */
/* 	double P_new[4][4]; */
/* 	multiply(F, P, res); */
/* 	multiply(res, FT, P_new); */

/* 	for (int i = 0; i < 4; i++) { */
/* 		for (int j = 0; j < 4; j++) { */
/* 			P[i][j] = P_new[i][j]; */
/* 		} */
/* 	} */
/* } */


/* void update(double z[2], double x_est[4]) { */
/* 	double residual[2] = {z[0] - x_post[0], z[1] - x_post[1]}; */
/* 	double S[2][2] = { */
/* 		{P[0][0] + R[0][0], 0}, */
/* 		{0, P[1][1] + R[1][1]} */
/* 	}; */
/* 	double S_INVERSE[2][2] = { */
/* 		{S[1][1] / (S[0][0] * S[1][1]), 	0							 }, */
/* 		{0, 								S[0][0] / (S[0][0] * S[1][1])} */
/* 	}; */
/* 	double K[4][2]; */
/* 	memset(K, 0, sizeof(K)); */
/* 	K[0][0] = P[0][0] * S_INVERSE[0][0]; */
/* 	K[1][1] = P[1][1] * S_INVERSE[1][1]; */
	
/* 	x_est[0] = x_post[0] + K[0][0] * residual[0]; */
/* 	x_est[1] = x_post[1] + K[1][1] * residual[1]; */
/* 	x_est[2] = x_post[2] + K[0][0] * (x_est[0] - x_prev[0]); */
/* 	x_est[3] = x_post[3] + K[1][1] * (x_est[1] - x_prev[1]); */


/* 	// Update P and x_prev */
/* 	P[0][0] = (1 - K[0][0]) * P[0][0]; */
/* 	P[1][1] = (1 - K[1][1]) * P[1][1]; */
/* 	x_prev[0] = x_est[0]; */
/* 	x_prev[1] = x_est[1]; */
/* 	x_prev[2] = x_est[2]; */
/* 	x_prev[3] = x_est[3]; */
/* } */
